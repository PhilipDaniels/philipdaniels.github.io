<!DOCTYPE html>
<html lang="en-us">
    
    


    <head>
    <link href="https://gmpg.org/xfn/11" rel="profile">
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta http-equiv="Cache-Control" content="public" />
<!-- Enable responsiveness on mobile devices -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="generator" content="Hugo 0.68.3" />

    
    
    

<title>A C# Source Generator for Oracle UDTs â€¢ Phil&#39;s Blog</title>


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="A C# Source Generator for Oracle UDTs"/>
<meta name="twitter:description" content="Introduction Working with Oracle recently, I found myself wanting an equivalent of SQL Server&rsquo;s Table-Valued Parameters - a way to pass structured records, or tables of such records, into stored procedures. The Oracle equivalent is the User-Defined Data Type but using them requires quite a bit of work. I&rsquo;ve created BassUtils.Oracle which contains helpers for creating the correct OracleCommand parameters, described in a previous blog post. But that still leaves you having to manually code the C# class that Oracle requires to map them to and from the Oracle SQL types."/>

<meta property="og:title" content="A C# Source Generator for Oracle UDTs" />
<meta property="og:description" content="Introduction Working with Oracle recently, I found myself wanting an equivalent of SQL Server&rsquo;s Table-Valued Parameters - a way to pass structured records, or tables of such records, into stored procedures. The Oracle equivalent is the User-Defined Data Type but using them requires quite a bit of work. I&rsquo;ve created BassUtils.Oracle which contains helpers for creating the correct OracleCommand parameters, described in a previous blog post. But that still leaves you having to manually code the C# class that Oracle requires to map them to and from the Oracle SQL types." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.philipdaniels.com/blog/2022/oracle-udt-class-generator/" />
<meta property="article:published_time" content="2022-01-12T00:00:00+00:00" />
<meta property="article:modified_time" content="2022-01-12T00:00:00+00:00" />


    


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/gruvbox-dark.min.css">








<link rel="stylesheet" href="/scss/hyde-hyde.328a08e64c91c64b1af9c913a417dacec4e78f52fc75317d3ca3aececc1e2290.css" integrity="sha256-MooI5kyRxksa&#43;ckTpBfazsTnj1L8dTF9PKOuzsweIpA=">


<link rel="stylesheet" href="/scss/print.2744dcbf8a0b2e74f8a50e4b34e5f441be7cf93cc7de27029121c6a09f9e77bc.css" integrity="sha256-J0Tcv4oLLnT4pQ5LNOX0Qb58&#43;TzH3icCkSHGoJ&#43;ed7w=" media="print">



    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    <!-- Icons -->
    <link rel="apple-touch-icon-precomposed" sizes="57x57" href="/apple-touch-icon-57x57.png" />
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="/apple-touch-icon-114x114.png" />
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="/apple-touch-icon-72x72.png" />
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144x144.png" />
    <link rel="apple-touch-icon-precomposed" sizes="60x60" href="/apple-touch-icon-60x60.png" />
    <link rel="apple-touch-icon-precomposed" sizes="120x120" href="/apple-touch-icon-120x120.png" />
    <link rel="apple-touch-icon-precomposed" sizes="76x76" href="/apple-touch-icon-76x76.png" />
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="/apple-touch-icon-152x152.png" />
    <link rel="icon" type="image/png" href="/favicon-196x196.png" sizes="196x196" />
    <link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96" />
    <link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32" />
    <link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16" />
    <link rel="icon" type="image/png" href="/favicon-128.png" sizes="128x128" />
    <meta name="msapplication-TileColor" content="#FFFFFF" />
    <meta name="msapplication-TileImage" content="/mstile-144x144.png" />
    <meta name="msapplication-square70x70logo" content="/mstile-70x70.png" />
    <meta name="msapplication-square150x150logo" content="/mstile-150x150.png" />
    <meta name="msapplication-wide310x150logo" content="/mstile-310x150.png" />
    <meta name="msapplication-square310x310logo" content="/mstile-310x310.png" />

    

    
        
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-QK1BLJ71TN');
</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-QK1BLJ71TN"></script>
    
</head>


    <body class=" ">
    
<div class="sidebar">
  <div class="container ">
    <div class="sidebar-about">
      <span class="site__title">
        <a href="https://www.philipdaniels.com/">Phil&#39;s Blog</a>
      </span>
      
      
        <div class="author-image">
          <img src="https://www.gravatar.com/avatar/5f3e5fe7d6a4062ad188336e06f1cb78?s=240&d=mp" class="img--circle img--headshot element--center" alt="gravatar">
        </div>
      
      <p class="site__description">
        
      </p>
    </div>
    <div class="collapsible-menu">
      <input type="checkbox" id="menuToggle">
      <label for="menuToggle">Phil&#39;s Blog</label>
      <div class="menu-content">
        <div>
	<ul class="sidebar-nav">
		 
		 
			 
				<li>
					<a href="/blog">
						<span>Posts</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/gitcheatsheet">
						<span>My Git CheatSheet</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/about">
						<span>About</span>
					</a>
				</li>
			 
		
		</li>
	</ul>
</div>

        <section class="social">
	
	
	
	<a href="https://github.com/PhilipDaniels" rel="me"><i class="fab fa-github fa-lg" aria-hidden="true"></i></a>
	
	
	
	
	
	
	<a href="https://stackoverflow.com/users/1313057/philip-daniels" rel="me"><i class="fab fa-stack-overflow fa-lg" aria-hidden="true"></i></a>
	
	
	
	
	
	
	
	<a href="mailto:philip.daniels1971@gmail.com" rel="me"><i class="fas fa-at fa-lg" aria-hidden="true"></i></a>
	
</section>

      </div>
    </div>
    
<div class="copyright">
  &copy; 2022 Philip Daniels
  
</div>



  </div>
</div>

        <div class="content container">
            
    <article>
  <header>
    <h1>A C# Source Generator for Oracle UDTs</h1>
    
    
<div class="post__meta">
    
    
      <i class="fas fa-calendar-alt"></i> Jan 12, 2022
    
    
    
    
    
      
      
          <br/>
           <i class="fas fa-tags"></i>
          
          <a class="badge badge-tag" href="/tags/c">c#</a>
           
      
          <a class="badge badge-tag" href="/tags/oracle">oracle</a>
           
      
          <a class="badge badge-tag" href="/tags/udt">udt</a>
           
      
          <a class="badge badge-tag" href="/tags/sql">sql</a>
           
      
          <a class="badge badge-tag" href="/tags/generator">generator</a>
           
      
          <a class="badge badge-tag" href="/tags/sprache">sprache</a>
           
      
          <a class="badge badge-tag" href="/tags/parsing">parsing</a>
           
      
          <a class="badge badge-tag" href="/tags/dsl">dsl</a>
           
      
          <a class="badge badge-tag" href="/tags/roslyn">roslyn</a>
          
      
    
    
    <br/>
    <i class="fas fa-clock"></i> 13 min read
</div>


  </header>
  
  
  <div class="post">
    <h1 id="introduction">Introduction</h1>
<p>Working with Oracle recently, I found myself wanting an equivalent of SQL Server&rsquo;s
Table-Valued Parameters - a way to pass structured records, or tables of such records,
into stored procedures. The Oracle equivalent is the
<a href="https://docs.oracle.com/en/database/oracle/oracle-data-access-components/19.3.2/odpnt/featUDTs.html#GUID-7913CDD0-CB22-4257-828F-FBCCA3FE9126">User-Defined Data Type</a>
but using them requires quite a bit of work. I&rsquo;ve created
<a href="https://www.nuget.org/packages/BassUtils.Oracle">BassUtils.Oracle</a>
which contains helpers for creating the correct <code>OracleCommand</code> parameters, described
in a <a href="https://www.philipdaniels.com/blog/2021/oracle-from-csharp/">previous blog post</a>.
But that still leaves you having to manually code the C# class that Oracle requires
to map them to and from the Oracle SQL types. And it&rsquo;s far from a POCO -
<a href="https://github.com/PhilipDaniels/OracleUdtClassGenerator/blob/master/OracleUdtClassGenerator.ConsoleTestHarness/GenerationExample.cs">example here</a> -
and has some strange, hard-to-discover rules, such as that all the Oracle field names
have to be in UPPERCASE or it just won&rsquo;t work.</p>
<p>Given that these classes all follow the same format it sounded like the perfect
opportunity to create a source generator and to use a DSL (Domain-Specific Language)
to simplify the definition of the classes. While the classes themselves are voluminous
there&rsquo;s not actually a lot of information required. It&rsquo;s possible to capture it all
in a significantly shorter form, an example of which is:</p>
<pre><code>class PersonRecord MYSCHEMA.objPerson
    Collection PersonArray MYSCHEMA.tblPerson
    Namespace People
    Fields [
        int Age,
        FirstName,
        LastName
    ]
</code></pre><p>To go from this to a C# class the steps are</p>
<ol>
<li>Parse this text into a specification, held in a C# class.</li>
<li>Use the specs to generate C# source code using a
<a href="https://devblogs.microsoft.com/dotnet/introducing-c-source-generators/">Source Generator</a></li>
<li>Package the source generator as a NuGet package.</li>
</ol>
<p>This post describes how I performed each of these steps. If you find yourself
wanting to generate a DSL-based Source Generator you can use this as a template.
The finished generator is availble on NuGet as
<a href="https://www.nuget.org/packages/OracleUdtClassGenerator/">OracleUdtClassGenerator</a>
and the source code is
<a href="https://github.com/PhilipDaniels/OracleUdtClassGenerator">available on GitHub</a>.
A list of current <a href="https://github.com/amis92/csharp-source-generators">C# Source Generators</a>
exists which may provide help and ideas for your own implementation.</p>
<h1 id="parsing">Parsing</h1>
<p>My first thought was &ldquo;this DSL is so simple I could parse it with a regex&rdquo;. But the regex
got bigger and nastier and I soon abandoned that idea. So what other approaches are there?
Obviously I could write a custom parser all by myself, and while
<a href="https://devblogs.microsoft.com/dotnet/using-c-source-generators-to-create-an-external-dsl/">that is the approach taken by Luca on the Microsoft team</a>
it&rsquo;s a little more work than I was hoping for. A full blown parser generator such as
<a href="http://putridparrot.com/blog/starting-out-with-antlr/">Antlr</a>
seemed like overkill, and installing Java is not something I wanted to do for this task.</p>
<p>Now there is a thing called <em>parser combinators</em>, which I first came across in the
<a href="https://docs.rs/nom/latest/nom/">Rust world</a>, though I never had the need to use it and
found the intros confusing, but it did stick in my mind as &lsquo;should be simple if I ever need
to write a parser&rsquo;. Briefly, parser combinators is an approach whereby you write lots of
little parsers to recognise small pieces of text - like the word &lsquo;class&rsquo; or &lsquo;Fields&rsquo; or a
newline - and then combine them with <em>combinators</em> like AND and OR or sequencing to make
new, larger parsers. Continue until you have a parser that can recognise your entire input.</p>
<p>This approach has two great advantages - you don&rsquo;t need to learn a new language to write
a grammar file, and it lends itself to stepwise refinement, so you can start simple and
test your parsers as you go along, gradually building them up to something more complex.</p>
<blockquote>
<p>Write unit tests to test your parser on all possible input variants. It is a lot
faster and easier than testing it in a NuGet package.</p>
</blockquote>
<p>A little Googling brought me to
<a href="https://github.com/sprache/sprache">Sprache</a>,
a parser combinator library for C# (Sprache is German for &lsquo;language&rsquo;). There are good
introductory articles by
<a href="https://nblumhardt.com/2010/01/building-an-external-dsl-in-c/">Nicholas Blumhardt</a>
and <a href="https://thomaslevesque.com/2017/02/23/easy-text-parsing-in-c-with-sprache/">Thomas Levesque</a>,
and <a href="https://justinpealing.me.uk/post/2020-03-11-sprache1-chars/">Justin Pealing</a> has produced
a whole list of reference articles on different Sprache techniques.</p>
<p>The grammer for my DSL is specified as a series of parsers using LINQ expressions. You can
probably figure out what is happening just by looking at the code (<code>TargetClassSpecification</code> is
the DTO that contains all the parsed information):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> Parser&lt;TargetClassSpecification&gt; TargetClassSpecificationParser =
    <span style="color:#66d9ef">from</span> classNames <span style="color:#66d9ef">in</span> ClassNameParser
    <span style="color:#66d9ef">from</span> collectionNames <span style="color:#66d9ef">in</span> CollectionNameParser.Optional()
    <span style="color:#66d9ef">from</span> namespaceName <span style="color:#66d9ef">in</span> NamespaceParser.Optional()
    <span style="color:#66d9ef">from</span> filename <span style="color:#66d9ef">in</span> FilenameParser.Optional()
    <span style="color:#66d9ef">from</span> ddspec <span style="color:#66d9ef">in</span> DebugParser.Optional()
    <span style="color:#66d9ef">from</span> tsspec <span style="color:#66d9ef">in</span> ToStringParser.Optional()
    <span style="color:#66d9ef">from</span> fields <span style="color:#66d9ef">in</span> FieldListParser
    <span style="color:#66d9ef">select</span> <span style="color:#66d9ef">new</span> TargetClassSpecification
    {
        FileName = filename.GetOrDefault(),
        Namespace = namespaceName.GetOrDefault(),
        ClassName = classNames.Item1,
        CollectionName = collectionNames.IsDefined ? collectionNames.Get().Item1 : <span style="color:#66d9ef">null</span>,
        OracleRecordTypeName = classNames.Item2,
        OracleCollectionTypeName = collectionNames.IsDefined ? collectionNames.Get().Item2 : <span style="color:#66d9ef">null</span>,
        DebuggerDisplayFormat = ddspec.GetOrDefault(),
        ToStringFormat = tsspec.GetOrDefault(),
        Fields = fields
    };
</code></pre></div><p>This declares one parser, which is composed from a sequence of sub-parsers such as <code>ClassNameParser</code> and
<code>CollectionNameParser</code> (which is optional). If the entire parse succeeds then a new <code>TargetClassSpecification</code>
object is created. At this level, most of the interesting code is tucked away in the sub-parsers, most of which
return single strings, but <code>ClassNameParser</code>and <code>CollectionNameParser</code> return tuples consisting of two strings.
I really admire the way that Sprache leverages LINQ to express sequencing.</p>
<p>If we dig into <code>ClassNameParser</code> we can see some of the lower-level techniques.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> Parser&lt;(<span style="color:#66d9ef">string</span>, <span style="color:#66d9ef">string</span>)&gt; ClassNameParser =
    <span style="color:#66d9ef">from</span> _ <span style="color:#66d9ef">in</span> Parse.IgnoreCase(<span style="color:#e6db74">&#34;CLASS&#34;</span>).TokenOnLine()
    <span style="color:#66d9ef">from</span> csharpClassName <span style="color:#66d9ef">in</span> Parse.Identifier(Parse.Letter, TokenChar).TokenOnLine().Text()
    <span style="color:#66d9ef">from</span> oracleObjectTypeName <span style="color:#66d9ef">in</span> Parse.Identifier(Parse.Letter, TokenChar).TokenOnLine().Text()
    <span style="color:#66d9ef">from</span> _2 <span style="color:#66d9ef">in</span> OptionalCommaParser
    <span style="color:#66d9ef">select</span> (csharpClassName, oracleObjectTypeName);
</code></pre></div><p>This is designed to parse the first line of this text:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">class PersonRecord MYSCHEMA.objPerson
    Collection PersonArray MYSCHEMA.tblPerson
    ...
</code></pre></div><p>First we look for the word &ldquo;CLASS&rdquo; to start off the entire specification. We use <code>Parse.IgnoreCase</code> in preference
to <code>Parse.String</code> here so the user can write in any case they want. <code>TokenOnLine()</code> eats whitespace around
tokens but doesn&rsquo;t consume newlines. (I had to write this specially because I used newline as a separator rather
than requiring a comma. This was probably a mistake, I should have used comma and the built-in <code>Token</code> parser
which <strong>does</strong> eat newlines). <code>Text()</code> turns a list of parsed chars into a string. Finally, if the parse succeeds
the <code>from _</code> means &ldquo;I don&rsquo;t care what you parsed, throw it away&rdquo;. Since the word &ldquo;class&rdquo; is just a keyword and
carries no information we need we can just dispose of it.</p>
<p>We <strong>do</strong> want to get the C# class name and the Oracle Object Type Name because we need them both for
the code generation step. All my sub-parsers leverage the <code>Parse.Identifier(first_char, subsequent_chars)</code>
built-in parser. I&rsquo;ve configured <code>TokenChar</code> so that this accepts letters, numbers, and dots, so that it can parse
&ldquo;MYSCHEMA.objPerson&rdquo; as well as &ldquo;Person.g.cs&rdquo; and &ldquo;PersonRecord&rdquo;.</p>
<p><code>OptionalCommaParser</code> is a &lsquo;tidy-up&rsquo; operation. It greedily consumes input consisting of either a comma or
whitespace and then stops. This means that the <em>overall</em> parser will be in a position to start the next parser, in
this case we will be at the &lsquo;C&rsquo; in &ldquo;Collection&rdquo;.</p>
<p>The other individual parsers for the namespace, debug display attribute etc. are all similar, and all optional.</p>
<p>Finally <code>FieldListParser</code> returns a list of <code>FieldSpecification</code> DTOs.
Notice how sequencing is handled simply by adding a new LINQ <code>from</code> expression. It&rsquo;s very easy to build
up from simple parsers to the final one.</p>
<p>The <code>TargetClassSpecificationParser</code> isn&rsquo;t actually the final word: the parsing is done by
this higher-level parser:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cs" data-lang="cs"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> Parser&lt;List&lt;TargetClassSpecification&gt;&gt; TargetClassSpecificationListParser =
    <span style="color:#66d9ef">from</span> t <span style="color:#66d9ef">in</span> TargetClassSpecificationParser.Many()
    <span style="color:#66d9ef">select</span> t.ToList();
</code></pre></div><p>This really demonstrates the power of the combinator approach with the <code>.Many()</code> call being all that
is required to say &ldquo;parse a list of these things from the input&rdquo; rather than just one.</p>
<h3 id="drill-down-into-fieldlistparser">Drill-down into FieldListParser</h3>
<p><code>FieldListParser</code> shows a couple of interesting techniques. It is defined as:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cs" data-lang="cs"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> Parser&lt;List&lt;FieldSpecification&gt;&gt; FieldListParser =
    <span style="color:#66d9ef">from</span> open <span style="color:#66d9ef">in</span> FieldKeywordParser
    <span style="color:#66d9ef">from</span> elements <span style="color:#66d9ef">in</span> FieldParser.DelimitedBy(FieldSeparatorParser)
    <span style="color:#66d9ef">from</span> _ws1 <span style="color:#66d9ef">in</span> Parse.WhiteSpace.Many()
    <span style="color:#66d9ef">from</span> close <span style="color:#66d9ef">in</span> Parse.Char(<span style="color:#e6db74">&#39;]&#39;</span>)
    <span style="color:#66d9ef">from</span> _ws2 <span style="color:#66d9ef">in</span> Parse.WhiteSpace.Many()
    <span style="color:#66d9ef">select</span> elements.ToList();

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> Parser&lt;<span style="color:#66d9ef">string</span>&gt; FieldSeparatorParser =
    <span style="color:#66d9ef">from</span> _ <span style="color:#66d9ef">in</span> Parse.LineEnd.Or(Parse.String(<span style="color:#e6db74">&#34;,&#34;</span>))
    <span style="color:#66d9ef">select</span> <span style="color:#e6db74">&#34;&#34;</span>;

<span style="color:#75715e">// Most consuming parser first.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> Parser&lt;FieldSpecification&gt; FieldParser =
    ThreePartFieldParser
    .Or(TwoPartFieldParser)
    .Or(OnePartFieldParser);
</code></pre></div><p><code>FieldKeywordParser</code> just eats the &ldquo;Fields [&rdquo; text, then we use <code>FieldParser</code>
to parse an individual field, which may have one, two or three parts. Since the
first parser to match terminates the parsing, we use the most specific three-part
matcher as the first, then try for a two-part match, then finally fall back
to the one-part matcher. We combine <code>FieldParser</code> using the Sprache built-in
<code>DelimitedBy</code> which makes it parse a <strong>list</strong> of fields, each field being separated by
<code>FieldSeparatorParser</code> - which may be a newline or a comma. This works because we
don&rsquo;t allow comma as a character in a token. You&rsquo;ll notice we explicitly eat
whitespace before we get to the closing &lsquo;]&rsquo; token. This is something of a theme,
you have to consume whitespace yourself, either like this or by using <code>Token</code> or
related methods.</p>
<p>The 3 field parsers are all similar, here is the three-part one:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cs" data-lang="cs"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> Parser&lt;FieldSpecification&gt; ThreePartFieldParser =
    <span style="color:#66d9ef">from</span> typeName <span style="color:#66d9ef">in</span> Parse.Identifier(Parse.Letter, TokenChar).TokenOnLine().Text()
    <span style="color:#66d9ef">from</span> propertyName <span style="color:#66d9ef">in</span> Parse.Identifier(Parse.Letter, TokenChar).TokenOnLine().Text()
    <span style="color:#66d9ef">from</span> oracleName <span style="color:#66d9ef">in</span> Parse.Identifier(Parse.Letter, TokenChar).TokenOnLine().Text()
    <span style="color:#66d9ef">select</span> <span style="color:#66d9ef">new</span> FieldSpecification
    {
        DotNetDataTypeName = typeName,
        PropertyName = propertyName,
        OracleFieldName = oracleName,
    };
</code></pre></div><p>Notice that at this level none of the properties are optional. The two-part is then
defined to omit <code>oracleName</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cs" data-lang="cs"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> Parser&lt;FieldSpecification&gt; TwoPartFieldParser =
    <span style="color:#66d9ef">from</span> typeName <span style="color:#66d9ef">in</span> Parse.Identifier(Parse.Letter, TokenChar).TokenOnLine().Text()
    <span style="color:#66d9ef">from</span> propertyName <span style="color:#66d9ef">in</span> Parse.Identifier(Parse.Letter, TokenChar).TokenOnLine().Text()
    <span style="color:#66d9ef">select</span> <span style="color:#66d9ef">new</span> FieldSpecification
    {
        DotNetDataTypeName = typeName,
        PropertyName = propertyName,
    };
</code></pre></div><blockquote>
<p>An alternative implementation could use a single FieldParser which gathers 1, 2 or 3
strings and then assigns them to the appropriate properties of the <code>FieldSpecification</code>
depending on how many strings were present.</p>
</blockquote>
<p>You can see the whole set of parsers at the Github repository but that&rsquo;s the main ones.
The stepwise refinement continues down to lower and lower levels until you reach parsers
for individual words and characters.</p>
<p>The top-level method that drives the parsing is defined like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> List&lt;TargetClassSpecification&gt; ParseTargetSpecs(<span style="color:#66d9ef">string</span> input)
{
    input = input.Trim();
    <span style="color:#66d9ef">var</span> specs = TargetClassSpecificationListParser.Parse(input);
    <span style="color:#66d9ef">return</span> specs;
}
</code></pre></div><h1 id="generating-the-udt">Generating the UDT</h1>
<p>With parsing the input taken care of we can move on to the second part, creating a
C# source generator. First you&rsquo;ll need to install the VS Extension Development Pack
using the Visual Studio Installer:</p>
<p><img src="vs_extension_development.png" alt="VS Extension Development"></p>
<p>A generator is quite easy to write - but debugging it is a different matter, more on
that later. To start, you have to implement the
<a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.codeanalysis.isourcegenerator?view=roslyn-dotnet-4.0.1">ISourceGenerator interface</a>. Create a class like this</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">using</span> Microsoft.CodeAnalysis;
<span style="color:#66d9ef">using</span> Microsoft.CodeAnalysis.Text;
<span style="color:#a6e22e">
</span><span style="color:#a6e22e">[Generator]</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">OracleUdtGenerator</span> : ISourceGenerator
{
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Initialize(GeneratorInitializationContext context)
    {
    }

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Execute(GeneratorExecutionContext context)
    {
    }
}
</code></pre></div><p>The body of your generator goes in the <code>Execute()</code> method. For this source generator
I don&rsquo;t need to do anything in <code>Initialize()</code>, but if necessary this is where
I would create a SyntaxReceiver for example if I wanted to generate based on the C# syntax tree. But
my use case is much simpler: <code>OracleUdtClassGenerator</code> is used by adding files ending with <code>.oraudt</code>
to a project as additional files:</p>
<p><img src="additional_files.png" alt="VS Extension Development"></p>
<p>So all we need to do during generation is find all these files, extract the text, parse it,
and use the parsed specifications to generate C#:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Execute(GeneratorExecutionContext context)
{
    <span style="color:#66d9ef">try</span>
    {
        <span style="color:#75715e">// Generating as we find each file produces better logs.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">foreach</span> (<span style="color:#66d9ef">var</span> file <span style="color:#66d9ef">in</span> context.AdditionalFiles)
        {
            <span style="color:#66d9ef">if</span> (Path.GetExtension(file.Path).Equals(<span style="color:#e6db74">&#34;.oraudt&#34;</span>, StringComparison.OrdinalIgnoreCase))
            {
                Logger.Log(<span style="color:#e6db74">$&#34;Found file {file.Path}&#34;</span>);
                ProcessAdditionalFile(context, file);
            }
        }

    }
    <span style="color:#66d9ef">catch</span> (Exception ex)
    {
        Logger.Log(ex.ToString());
    }

    Logger.WriteLogsToFile(context);
}

<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> ProcessAdditionalFile(GeneratorExecutionContext context, AdditionalText file)
{
    <span style="color:#66d9ef">try</span>
    {
        <span style="color:#66d9ef">var</span> text = file.GetText()?.ToString();
        <span style="color:#66d9ef">if</span> (!<span style="color:#66d9ef">string</span>.IsNullOrEmpty(text))
        {
            ProcessAdditionalFileContents(context, file, text);
        }
    }
    <span style="color:#66d9ef">catch</span> (Exception ex)
    {
        Logger.Log(ex.ToString());
    }
}

<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> ProcessAdditionalFileContents(GeneratorExecutionContext context, AdditionalText file, <span style="color:#66d9ef">string</span> text)
{
    <span style="color:#66d9ef">try</span>
    {
        <span style="color:#66d9ef">var</span> targetSpecs = Grammar.ParseTargetSpecs(text);
        <span style="color:#66d9ef">foreach</span> (<span style="color:#66d9ef">var</span> spec <span style="color:#66d9ef">in</span> targetSpecs)
        {
            Logger.Log(<span style="color:#e6db74">$&#34;  Found spec for {spec.ClassName} with {spec.Fields.Count} fields&#34;</span>);
            CreateSourceFile(context, file, spec);
        }
    }
    <span style="color:#66d9ef">catch</span> (Exception ex)
    {
        Logger.Log(ex.ToString());
    }
}
</code></pre></div><p>Note the call to <code>Grammer.ParseTargetSpecs(text)</code> - this is where we pass the contents of the
<code>.oraudt</code> file into the Sprache grammar parser and get back a list of class specifications which
will drive the C# source code generation in <code>CreateSourceFile</code>.</p>
<p>A note on the logging and exception trapping in these methods. During development debugging
source generators is something of a pain. You can attach a debugger to the running generator
using:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">if</span> (!Debugger.IsAttached)
{
    Debugger.Launch();
}
</code></pre></div><p>but I found it preferable to generate a log as an array of strings as the generator runs
and then write that out to a file as the final step. The exception blocks ensure that if
something blows up on one file that the generator continues and tries to complete as much
work as possible. The results of running the generator are visible under the &lsquo;Analyzers&rsquo;
node in Visual Studio. (Visual Studio can sometimes be a bit reluctant to show these files,
restarting VS will make them visible). The &lsquo;_Logs.cs&rsquo; file contains the log messages
inside a C# comment, looking something like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cs" data-lang="cs"><span style="color:#75715e">/*
</span><span style="color:#75715e">DateTime.UtcNow: 2022-01-01T22:33:03.5397481Z
</span><span style="color:#75715e">
</span><span style="color:#75715e">Found file C:\repos\OracleUdtClassGenerator\OracleUdtClassGenerator.ConsoleTestHarness\ArticleMaster.oraudt
</span><span style="color:#75715e">  Found spec for ArticleMasterRecord with 17 fields
</span><span style="color:#75715e">  Generated file ArticleMasterRecord.g.cs in namespace OracleUdtClassGenerator.ConsoleTestHarness
</span><span style="color:#75715e">Found file C:\repos\OracleUdtClassGenerator\OracleUdtClassGenerator.ConsoleTestHarness\MyClass.oraudt
</span><span style="color:#75715e">  Found spec for MyClass with 5 fields
</span><span style="color:#75715e">  Generated file MyClass.g.cs in namespace MyNamespace
</span><span style="color:#75715e">Found file C:\repos\OracleUdtClassGenerator\OracleUdtClassGenerator.ConsoleTestHarness\SubFolder\ArticleMaster2.oraudt
</span><span style="color:#75715e">  Found spec for ArticleMasterRecord2 with 17 fields
</span><span style="color:#75715e">  Generated file ArticleMasterRecord2.g.cs in namespace OracleUdtClassGenerator.ConsoleTestHarness.SubFolder
</span><span style="color:#75715e">Found file C:\repos\OracleUdtClassGenerator\OracleUdtClassGenerator.ConsoleTestHarness\Person.oraudt
</span><span style="color:#75715e">  Found spec for PersonRecord with 3 fields
</span><span style="color:#75715e">  Generated file PersonRecord.g.cs in namespace People
</span><span style="color:#75715e">*/</span>
</code></pre></div><p><img src="generated_code.png" alt="VS Extension Development"></p>
<p>If the generator is not working correctly, you will probably get the dreaded
&lsquo;not generating files&rsquo; error:</p>
<p><img src="not_generating_files.png" alt="VS Extension Development"></p>
<p>Catching all exceptions and logging them prevents this and also gives a clue as to what
is going wrong.</p>
<h2 id="the-createsourcefile-method">The CreateSourceFile method</h2>
<p>This bit of code, which does the actual work of creating the C# classes, is the longest
but least interesting part of the project. It basically uses the <code>TargetClassSpecification</code>
DTO to drive the output of the C# code into a <code>StringBuilder</code>, and when done it adds
the contents of the builder to the generation context:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cs" data-lang="cs"><span style="color:#66d9ef">var</span> source = GenerateSourceText(context, spec, ns);
<span style="color:#66d9ef">var</span> filename = <span style="color:#e6db74">$&#34;{spec.ClassName}.g.cs&#34;</span>;
Logger.Log(<span style="color:#e6db74">$&#34;  Generated file {filename} in namespace {ns}&#34;</span>);
context.AddSource(filename, SourceText.From(source, Encoding.UTF8));
</code></pre></div><p>I made use of a utility class I have written called an
<a href="https://github.com/PhilipDaniels/OracleUdtClassGenerator/blob/master/OracleUdtClassGenerator/IndentingStringBuilder.cs">IndentingStringBuilder</a>
to simplify the C# generation. It indents when you call <code>BeginCodeBlock</code> and outdents
automatically on <code>Dispose</code>, so you can do</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cs" data-lang="cs"><span style="color:#66d9ef">using</span> (sb.BeginCodeBlock())
{
    sb.AppendLine(<span style="color:#e6db74">&#34;public IOracleCustomType CreateObject()&#34;</span>);
    <span style="color:#66d9ef">using</span> (sb.BeginCodeBlock())
    {
        sb.AppendLine(<span style="color:#e6db74">$&#34;return new {spec.ClassName}();&#34;</span>);
    }
}

<span style="color:#75715e">// results in
</span><span style="color:#75715e"></span>{
    <span style="color:#66d9ef">public</span> IOracleCustomType CreateObject()
    {
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> PersonRecord();
    }
}
</code></pre></div><p>This class lives in my <a href="https://www.nuget.org/packages/BassUtils/">BassUtils</a> NuGet package, but I
copied and pasted it into the generator to avoid having another NuGet dependency to deal with (see
below for the problems they cause). This thinking also meant I decided not to use a templating library
to assist with the code generation.</p>
<h1 id="packaging-as-a-nuget-package">Packaging as a NuGet Package</h1>
<p>When packaged as a NuGet package, we want our source generator to run at compile time
only, and not to become a deployment dependency of the project that it is deployed in.
I followed the
<a href="https://github.com/dotnet/roslyn/blob/main/docs/features/source-generators.cookbook.md#use-functionality-from-nuget-packages">official recipe</a> to do this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml"><span style="color:#f92672">&lt;PropertyGroup&gt;</span>
    <span style="color:#f92672">&lt;GeneratePackageOnBuild&gt;</span>true<span style="color:#f92672">&lt;/GeneratePackageOnBuild&gt;</span>
    <span style="color:#75715e">&lt;!-- The generator lib is used only at compile time, clients do not need it at run time as it
</span><span style="color:#75715e">	contains nothing they use. This stops NuGet from packing anything from this project, so we
</span><span style="color:#75715e">	will include dependencies manually below. --&gt;</span>
    <span style="color:#f92672">&lt;IncludeBuildOutput&gt;</span>false<span style="color:#f92672">&lt;/IncludeBuildOutput&gt;</span>
    <span style="color:#75715e">&lt;!-- Change the default output folder for the build --&gt;</span>
    <span style="color:#f92672">&lt;BuildOutputTargetFolder&gt;</span>analyzers<span style="color:#f92672">&lt;/BuildOutputTargetFolder&gt;</span>
<span style="color:#f92672">&lt;/PropertyGroup&gt;</span>
</code></pre></div><p>Now that everything is being packed into an &lsquo;analyzers&rsquo; folder, you will start getting this warning
from NuGet.</p>
<pre><code>warning NU5128: Some target frameworks declared in the dependencies group of the nuspec and the lib/ref folder do not have exact matches in the other location. Consult the list of actions below:
warning NU5128: - Add lib or ref assemblies for the netstandard2.0 target framework
</code></pre><p>You can suppress this in the project file:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml"><span style="color:#f92672">&lt;PropertyGroup&gt;</span>
  <span style="color:#f92672">&lt;NoWarn&gt;</span>NU5128<span style="color:#f92672">&lt;/NoWarn&gt;</span>
<span style="color:#f92672">&lt;/PropertyGroup&gt;</span>
</code></pre></div><p>We have to ensure that the NuGet package includes the dependencies that we used while
writing it. If we don&rsquo;t do this users of the NuGet will get a runtime error along the lines
of &lsquo;cannot find file or assembly&hellip;'. For our <code>OracleUdtClassGenerator</code>, it&rsquo;s just Sprache:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml"><span style="color:#f92672">&lt;ItemGroup&gt;</span>
    <span style="color:#75715e">&lt;!-- Generator dependencies --&gt;</span>
    <span style="color:#f92672">&lt;PackageReference</span> <span style="color:#a6e22e">Include=</span><span style="color:#e6db74">&#34;Sprache&#34;</span> <span style="color:#a6e22e">Version=</span><span style="color:#e6db74">&#34;2.3.1&#34;</span> <span style="color:#a6e22e">PrivateAssets=</span><span style="color:#e6db74">&#34;all&#34;</span> <span style="color:#a6e22e">GeneratePathProperty=</span><span style="color:#e6db74">&#34;true&#34;</span> <span style="color:#f92672">/&gt;</span>
<span style="color:#f92672">&lt;/ItemGroup&gt;</span>

<span style="color:#f92672">&lt;ItemGroup&gt;</span>
    <span style="color:#75715e">&lt;!-- Package the generator in the analyzer directory of the nuget package --&gt;</span>
    <span style="color:#f92672">&lt;None</span> <span style="color:#a6e22e">Include=</span><span style="color:#e6db74">&#34;$(OutputPath)\$(AssemblyName).dll&#34;</span> <span style="color:#a6e22e">Pack=</span><span style="color:#e6db74">&#34;true&#34;</span> <span style="color:#a6e22e">PackagePath=</span><span style="color:#e6db74">&#34;analyzers/dotnet/cs&#34;</span> <span style="color:#a6e22e">Visible=</span><span style="color:#e6db74">&#34;false&#34;</span> <span style="color:#f92672">/&gt;</span>
    <span style="color:#75715e">&lt;!-- Package the our dependencies alongside the generator assembly --&gt;</span>
    <span style="color:#f92672">&lt;None</span> <span style="color:#a6e22e">Include=</span><span style="color:#e6db74">&#34;$(PkgSprache)\lib\netstandard2.0\Sprache*.dll&#34;</span> <span style="color:#a6e22e">Pack=</span><span style="color:#e6db74">&#34;true&#34;</span> <span style="color:#a6e22e">PackagePath=</span><span style="color:#e6db74">&#34;analyzers/dotnet/cs&#34;</span> <span style="color:#a6e22e">Visible=</span><span style="color:#e6db74">&#34;false&#34;</span> <span style="color:#f92672">/&gt;</span>
<span style="color:#f92672">&lt;/ItemGroup&gt;</span>
</code></pre></div><p>Notice how everything is packaged into the &lsquo;analyzers&rsquo; folder, you can examine the final
folder structure using the
<a href="https://github.com/NuGetPackageExplorer/NuGetPackageExplorer">NuGet Package Explorer</a>:</p>
<p><img src="nuget_folder_structure.png" alt="VS Extension Development"></p>
<p>The package should have no dependencies:</p>
<p><img src="nuget_no_dependencies.png" alt="VS Extension Development"></p>
<p>And that completes the NuGet package.</p>
<p>One last thought: I found it easier to test the generator <strong>as</strong> as a NuGet package
within my solution, rather than adding a Project Reference. As we have seen, there
are significant complexities in creating the NuGet package and using a Project Reference
doesn&rsquo;t exercise those scenarios at all.</p>

  </div>
  

<div class="navigation navigation-single">
    
    <a href="/blog/2021/oracle-from-csharp/" class="navigation-prev">
      <i aria-hidden="true" class="fa fa-chevron-left"></i>
      <span class="navigation-tittle">BassUtils.Oracle - Helpers for Calling Oracle from C#</span>
    </a>
    
    
</div>


  

  
    
        <div id="disqus_thread"></div>
<script type="text/javascript">
    

    (function () {
    if (location.hostname === "localhost" ||
      location.hostname === "127.0.0.1" ||
      location.hostname === "") {
      return;
    }
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    var disqus_shortname = 'philipdanielscomblog';
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || 
      document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>

<noscript>
  Please enable JavaScript to view the
  <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a>
</noscript>
<a href="http://disqus.com/" class="dsq-brlink">comments powered by
  <span class="logo-disqus">Disqus</span>
</a>

    


</article>


        </div>
        
    
  
  
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-QK1BLJ71TN');
</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-QK1BLJ71TN"></script>

<script defer src="https://use.fontawesome.com/releases/v5.5.0/js/all.js" integrity="sha384-GqVMZRt5Gn7tB9D9q7ONtcp4gtHIUEW/yG7h98J7IpE3kpi+srfFyyB/04OV6pG0" crossorigin="anonymous"></script>


    
    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script>
        
            
                <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/languages/rust.min.js"></script>
            
                <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/languages/cs.min.js"></script>
            
                <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/languages/bash.min.js"></script>
            
                <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/languages/python.min.js"></script>
            
                <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/languages/css.min.js"></script>
            
                <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/languages/http.min.js"></script>
            
                <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/languages/ini.min.js"></script>
            
                <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/languages/javascript.min.js"></script>
            
                <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/languages/json.min.js"></script>
            
                <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/languages/markdown.min.js"></script>
            
                <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/languages/sql.min.js"></script>
            
                <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/languages/html.min.js"></script>
            
                <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/languages/xml.min.js"></script>
            
                <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/languages/dockerfile.min.js"></script>
            
                <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/languages/scss.min.js"></script>
            
                <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/languages/r.min.js"></script>
            
                <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/languages/typescript.min.js"></script>
            
                <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/languages/go.min.js"></script>
            
                <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/languages/cpp.min.js"></script>
            
                <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/languages/dos.min.js"></script>
            
                <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/languages/plaintext.min.js"></script>
            
                <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/languages/powershell.min.js"></script>
            
                <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/languages/diff.min.js"></script>
            
                <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/languages/makefile.min.js"></script>
            
                <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/languages/lisp.min.js"></script>
            
        
    
    <script type="text/javascript">
        
        hljs.configure({languages: ["rust, cs, bash, python, css, http, ini, javascript, json, markdown, sql, html, xml, dockerfile, scss, r, typescript, go, cpp, dos, plaintext, powershell, diff, makefile, lisp"]});
        
        hljs.initHighlightingOnLoad();
    </script>
    




    



    </body>
</html>
